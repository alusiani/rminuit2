% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rminuit2.R
\name{rminuit2_par}
\alias{rminuit2_par}
\title{Function Minimization with Minuit2}
\usage{
rminuit2_par(mll, start, err = NULL, lower = NULL, upper = NULL,
  fix = NULL, opt = "h", maxcalls = 0L, nsigma = 1, envir = NULL, ...)
}
\arguments{
\item{mll}{The function to be minimized, which must have as first
  argument a numeric vector of the parameters to be optimized. Futher
  arguments can be specified as optional arguments in \code{rminuit2_par}.

  The function can
  also be an external pointer to a C++ function compiled using the
  \code{inline} interface. For more info about implementing the objective
  function as compiled C++ code, see the
  \href{https://cran.r-project.org/web/packages/lbfgs/index.html}{lbfgs} package vignette.

  The full potential of this package is attained when the function corresponds to
  the negative logarithm of a likelihood or minus-log-likelihood (MLL).}

\item{start}{numeric vector, initial values of the function parameters}

\item{err}{numeric vector, expected uncertainty of function parameters}

\item{lower}{numeric vector, lower bounds for the parameters (default none)}

\item{upper}{numeric vector, upper bounds for the parameters (default none)}

\item{fix}{boolean vector, each TRUE element fixes the corresponding parameter}

\item{opt}{string, pass fit options, default "h" (compute HESSE errors)
\describe{
\item{\code{v}:}{Verbose mode (not yet implemented)}
\item{\code{h}:}{Run Hesse to estimate errors}
\item{\code{m}:}{Get Minos errors}
\item{\code{0}:}{Run Migrad with strategy 0}
\item{\code{1}:}{Run Migrad with strategy 1}
\item{\code{2}:}{Run Migrad with strategy 2}
\item{neither \code{1}, \code{2}, \code{3}:}{Run Migrad with strategy 1, and if it fails run with strategy 2}
}}

\item{maxcalls}{integer, maximum number of calls, defaults to \code{0} (no limit).}

\item{nsigma}{numeric, number of standard deviations for Minos errors}

\item{envir}{An R environment containing all extra arguments to be passed
to the mll function, if the mll function is implemented in C++. Arguments
must be matched exactly. If the mll function is implemented in R
then the extra arguments should be passed to it using the optional arguments
in \code{...} instead.}

\item{...}{extra arguments for the mll function, it the mll function is implemented in R.
If the mll function is implemented in C++ then the extra arguments
should be passed to it using the \code{envir} argument instead.}
}
\value{
A list with the following components:
 \describe{
   \item{\code{fval}:}{Value of function at found minimum (1/2 * chi square if the function is the negative log-likelihood of a Gaussian  likelihood.}
   \item{\code{Edm}:}{Estimated distance from the value of the function true minimum}
   \item{\code{par}:}{Fitted parameters}
   \item{\code{err}:}{Estimated uncertainties of fitted parameters}
   \item{\code{cov}:}{Covariance matrix of the fitted parameters}
   \item{\code{err_minos_pos}:}{Minos-estimated positive parameters' uncertainties (if Minos errors were requested)}
   \item{\code{err_minos_neg}:}{Minos-estimated negative parameters' uncertainties (if Minos errors requested)}
   \item{\code{err_minos_pos_valid}:}{boolean vector, TRUE if Minos positive uncertainties are valid (if Minos errors were requested)}
   \item{\code{err_minos_neg_valid}:}{boolean vector, TRUE if Minos negative uncertainties are valid (if Minos errors were requested)}
   \item{\code{allOK}:}{TRUE if the fit converged and the parameters and their covariance are OK}
   \item{\code{MinosErrorsValid}:}{TRUE if the MINOS errors are all valid}
   \item{\code{IsValid}:}{TRUE if the fit minimization converged}
   \item{\code{IsValidFirstInvocation}:}{TRUE if Minuit strategy 1 succeeded (if it failed Minuit2 strategy 2 is performed)}
   \item{\code{IsAboveMaxEdm}:}{TRUE if the estimated distance from the true minimum is above the tolerance}
   \item{\code{HasReachedCallLimit}:}{TRUE if the maximum call limit was exceeded}
   \item{\code{HasValidParameters}:}{TRUE if the fitted parameters are considered valid}
   \item{\code{HasCovariance}:}{TRUE if a covariance matrix is returned}
   \item{\code{HasValidCovariance}:}{TRUE if the estimated covariance matrix is considered valid}
   \item{\code{HasAccurateCovar}:}{TRUE if the accuracy of the estimated covariance matrix is considered valid}
   \item{\code{HasPosDefCovar}:}{TRUE if the numerically computed covariance matrix is positive definite}
   \item{\code{HasMadePosDefCovar}:}{TRUE if the covariance matrix has been adjusted to make it positive definite}
   \item{\code{HesseFailed}:}{TRUE if the numeric computation of the HESSE matrix failed}
 }
}
\description{
Performs function minimization using
\href{https://project-mathlibs.web.cern.ch/project-mathlibs/sw/Minuit2/html/index.html}{Minuit2}
}
\examples{
#
# Rosenbrock Banana function, to be minimized vs. 2 paramaters
#
rosenbrock <- function(par, a, b) {
  x <- par[1]
  y <- par[2]
  (a-x)^2 + b*(y-x^2)^2
}

# minimize Rosenbrock Banana function, also setting parameters a, b
fit.rc <- rminuit2_par(rosenbrock, c(x=0.7, y=1.2), a=1, b=100)

# print fitted parameters
fit.rc$par

#
# simulate model y = a*exp(-x/b)
#
x = seq(0, 1, length.out=31)
y.func = function(x, par) par[1]*exp(-x/par[2])

# simulate data with Gaussian errors for specific model
model.par = c(a=2.3, b=0.47)
y.err = 0.01
y = y.func(x, par=model.par) + rnorm(sd=y.err, n=length(x))

# negative log-likelihood for model
halfchisq = function(par, x, y, y.err) {
  sum( (y - y.func(x, par))^2 / (2 * y.err^2) )
}

# fit model on data, ask to compute Minos errors too
fit.rc = rminuit2_par(halfchisq, c(a=1, b=10), opt="hm", x=x, y=y, y.err=y.err)

# chi square / number of degrees of freedom
cbind(chisq=2*fit.rc$fval, ndof=length(x) - length(model.par))

cbind(model.value=model.par, value=fit.rc$par, error=fit.rc$err,
      minos_pos=fit.rc$err_minos_pos, minos_neg=fit.rc$err_minos_neg)

# parameters' correlation matrix
fit.rc$cor

}
\seealso{
rminuit2
}
